# -*- coding: utf-8 -*-
"""LVADSUSR154_HareeshKumaar_Fin_Lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EgMaMetl-zMDNQRtBNWXIjdPlDO_EG9J
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from scipy.cluster.hierarchy import dendrogram, linkage
from scipy.cluster.hierarchy import fcluster
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler,LabelEncoder
le=LabelEncoder()
from sklearn.cluster import KMeans
from sklearn.metrics import accuracy_score, precision_score, recall_score, confusion_matrix, classification_report,f1_score
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from imblearn.over_sampling import SMOTE

import warnings
warnings.filterwarnings("ignore")

df = pd.read_csv("/content/customer_segmentation.csv")
df.head(10)

df.shape

df.describe(include='all')

df.info()

df.columns

df.isnull().sum()

df.Income =df.Income.fillna(df.Income.median())

df.isnull().sum()

plt.figure(figsize=(18,14))
sns.heatmap(df.select_dtypes(include = ['int64','float64']).corr(),annot=True)

print(df.select_dtypes(include = ['int64','float64']).corr())

df.duplicated().sum()

df.info()

df.head(2)

df.columns

df.drop(columns=['ID','Dt_Customer'], inplace=True)

df.Education = le.fit_transform(df.Education)
df.Marital_Status = le.fit_transform(df.Marital_Status)

df.dtypes

#Outlier boxplot
# Identify numerical columns by data type
numerical_columns = df.select_dtypes(include=['float64', 'int64']).columns

# Create a box plot for each numerical column
for column in numerical_columns:
    plt.figure(figsize=(10, 6))  # Set the figure size for better readability
    sns.boxplot(x=df[column])
    plt.title(f'Box Plot of {column}')
    plt.xlabel(column)
    plt.show()

#Outlier detection
q1 = np.quantile(df["NumDealsPurchases"] , 0.25)
q3 = np.quantile(df["NumDealsPurchases"] , 0.75)
iqr = q3 - q1
lower_bound = q1 - 1.5 * iqr
upper_bound = q3 + 1.5 * iqr
print("Q1:", q1)
print("Q3:", q3)
print("IQR:", iqr)
print("Lower Bound (Outlier):", lower_bound)
print("Upper Bound (Outlier):", upper_bound)
# Identify outliers
outliers = [i for i in df["NumDealsPurchases"] if i < lower_bound or i > upper_bound]
print("Outliers:", outliers)

df.columns

scaler = MinMaxScaler()
scaled = scaler.fit_transform(df)

df.head(5)

km = KMeans(n_clusters=2)
y_predicted = km.fit_predict(df[['Income','Recency']])
print(y_predicted)

df['cluster']=y_predicted
print(df.head())

##
print(km.cluster_centers_)


df1 = df[df.cluster==0]
df2 = df[df.cluster==1]
df3 = df[df.cluster==2]
plt.scatter(df1['Income'],df1['Recency'],color='green')
plt.scatter(df2['Income'],df2['Recency'],color='red')
#plt.scatter(df3['Income'],df3['Recency'],color='black')

plt.scatter(km.cluster_centers_[:,0],km.cluster_centers_[:,1],color='purple',marker='*',label='centroid')
#plt.scatter(centroid['Length of kernel'],centroid['Perimeter'],marker='*',color="red")

plt.xlabel('Income')
plt.ylabel('Recency')
plt.legend()

sse = [] # The sum of Squared Errors =SSE
k_rng = range(1,10)
for k in k_rng:
   km = KMeans(n_clusters=k)
   km.fit(df[['Recency','Income']])
   sse.append(km.inertia_)

plt.xlabel('K')
plt.ylabel('Sum of squared error')
plt.plot(k_rng,sse)

km = KMeans(n_clusters=2)
y_predicted = km.fit_predict(df[['Income','Recency']])
print(y_predicted)

df['cluster']=y_predicted
print(df.head())


print(km.cluster_centers_)


df1 = df[df.cluster==0]
df2 = df[df.cluster==1]
df3 = df[df.cluster==2]
plt.scatter(df1['Income'],df1['Recency'],color='green')
plt.scatter(df2['Income'],df2['Recency'],color='red')
plt.scatter(df3['Income'],df3['Recency'],color='black')
plt.scatter(km.cluster_centers_[:,0],km.cluster_centers_[:,1],color='purple',marker='*',label='centroid')



plt.xlabel('Income')
plt.ylabel('Recency')
plt.legend()

print(silhouette_score(df[['Income','Recency']],y_predicted))

print("Inertia:", km.inertia_)